"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = __importDefault(require("path"));
var fs_1 = __importDefault(require("fs"));
var typescript_1 = __importDefault(require("typescript"));
var createDefaultFilesIfNotExists_1 = __importDefault(require("./createDefaultFilesIfNotExists"));
var findRootFiles = function (dir) {
    return fs_1.default
        .readdirSync(dir, { withFileTypes: true })
        .reduce(function (prev, d) { return __spread(prev, (d.isDirectory()
        ? findRootFiles(dir + "/" + d.name)
        : d.name === 'hooks.ts' || d.name === 'controller.ts'
            ? [dir + "/" + d.name]
            : [])); }, []);
};
var initTSC = function (appDir, project) {
    var configDir = path_1.default.resolve(project.replace(/\/[^/]+\.json$/, ''));
    var configFileName = typescript_1.default.findConfigFile(configDir, typescript_1.default.sys.fileExists, project.endsWith('.json') ? project.split('/').pop() : undefined);
    var compilerOptions = configFileName
        ? typescript_1.default.parseJsonConfigFileContent(typescript_1.default.readConfigFile(configFileName, typescript_1.default.sys.readFile).config, typescript_1.default.sys, configDir)
        : undefined;
    var program = typescript_1.default.createProgram(findRootFiles(appDir), (compilerOptions === null || compilerOptions === void 0 ? void 0 : compilerOptions.options) ? { baseUrl: compilerOptions === null || compilerOptions === void 0 ? void 0 : compilerOptions.options.baseUrl, paths: compilerOptions === null || compilerOptions === void 0 ? void 0 : compilerOptions.options.paths }
        : {});
    return { program: program, checker: program.getTypeChecker() };
};
var createRelayFile = function (input, appText, additionalReqs, params) {
    var hasAdditionals = !!additionalReqs.length;
    var hasMultiAdditionals = additionalReqs.length > 1;
    var text = "/* eslint-disable */\nimport { FastifyInstance, onRequestHookHandler, preParsingHookHandler, preValidationHookHandler, preHandlerHookHandler } from 'fastify'\nimport { Schema } from 'fast-json-stringify'\nimport { HttpStatusOk } from 'aspida'\nimport { Deps, depend } from 'velona'\nimport { ServerMethods } from '" + appText + "'\n" + (hasMultiAdditionals
        ? additionalReqs
            .map(function (req, i) {
            return "import { AdditionalRequest as AdditionalRequest" + i + " } from '" + req.replace(/^\.\/\./, '.') + "'\n";
        })
            .join('')
        : hasAdditionals
            ? "import { AdditionalRequest } from '" + additionalReqs[0] + "'\n"
            : '') + "import { Methods } from './'\n\n" + (hasMultiAdditionals
        ? "type AdditionalRequest = " + additionalReqs
            .map(function (_, i) { return "AdditionalRequest" + i; })
            .join(' & ') + "\n"
        : '') + (hasAdditionals
        ? 'type AddedHandler<T> = T extends (req: infer U, ...args: infer V) => infer W ? (req: U & Partial<AdditionalRequest>, ...args: V) => W : never\n'
        : '') + "type Hooks = {\n" + [
        ['onRequest', 'onRequestHookHandler'],
        ['preParsing', 'preParsingHookHandler'],
        ['preValidation', 'preValidationHookHandler'],
        ['preHandler', 'preHandlerHookHandler']
    ]
        .map(function (_a) {
        var _b = __read(_a, 2), key = _b[0], val = _b[1];
        return hasAdditionals
            ? "  " + key + "?: AddedHandler<" + val + "> | AddedHandler<" + val + ">[]\n"
            : "  " + key + "?: " + val + " | " + val + "[]\n";
    })
        .join('') + "}\ntype ControllerMethods = ServerMethods<Methods, " + (hasAdditionals ? 'AdditionalRequest & ' : '') + "{" + (params.length
        ? "\n  params: {\n" + params.map(function (v) { return "    " + v[0] + ": " + v[1]; }).join('\n') + "\n  }\n"
        : '') + "}>\n\nexport function defineResponseSchema<T extends { [U in keyof ControllerMethods]?: { [V in HttpStatusOk]?: Schema }}>(methods: () => T) {\n  return methods\n}\n\nexport function defineHooks<T extends Hooks>(hooks: (fastify: FastifyInstance) => T): (fastify: FastifyInstance) => T\nexport function defineHooks<T extends Record<string, any>, U extends Hooks>(deps: T, cb: (d: Deps<T>, fastify: FastifyInstance) => U): { (fastify: FastifyInstance): U; inject(d: Deps<T>): (fastify: FastifyInstance) => U }\nexport function defineHooks<T extends Record<string, any>>(hooks: (fastify: FastifyInstance) => Hooks | T, cb?: (deps: Deps<T>, fastify: FastifyInstance) => Hooks) {\n  return cb && typeof hooks !== 'function' ? depend(hooks, cb) : hooks\n}\n\nexport function defineController(methods: (fastify: FastifyInstance) => ControllerMethods): (fastify: FastifyInstance) => ControllerMethods\nexport function defineController<T extends Record<string, any>>(deps: T, cb: (d: Deps<T>, fastify: FastifyInstance) => ControllerMethods): { (fastify: FastifyInstance): ControllerMethods; inject(d: Deps<T>): (fastify: FastifyInstance) => ControllerMethods }\nexport function defineController<T extends Record<string, any>>(methods: (fastify: FastifyInstance) => ControllerMethods | T, cb?: (deps: Deps<T>, fastify: FastifyInstance) => ControllerMethods) {\n  return cb && typeof methods !== 'function' ? depend(methods, cb) : methods\n}\n";
    fs_1.default.writeFileSync(path_1.default.join(input, '$relay.ts'), text.replace(', {}', '').replace(' & {}', ''), 'utf8');
};
var getAdditionalResPath = function (input, name) {
    return fs_1.default.existsSync(path_1.default.join(input, name + ".ts")) &&
        /(^|\n)export .+ AdditionalRequest(,| )/.test(fs_1.default.readFileSync(path_1.default.join(input, name + ".ts"), 'utf8'))
        ? ["./" + name]
        : [];
};
var createFiles = function (appDir, dirPath, params, appPath, additionalRequestPaths) {
    var input = path_1.default.posix.join(appDir, dirPath);
    var appText = "../" + appPath;
    var additionalReqs = __spread(additionalRequestPaths.map(function (p) { return "./." + p; }), getAdditionalResPath(input, 'hooks'));
    createRelayFile(input, appText, __spread(additionalReqs, getAdditionalResPath(input, 'controller')), params);
    createDefaultFilesIfNotExists_1.default(input);
    fs_1.default.readdirSync(input, { withFileTypes: true }).forEach(function (d) {
        var _a;
        return d.isDirectory() &&
            createFiles(appDir, path_1.default.posix.join(dirPath, d.name), d.name.startsWith('_')
                ? __spread(params, [[d.name.slice(1).split('@')[0], (_a = d.name.split('@')[1]) !== null && _a !== void 0 ? _a : 'string']]) : params, appText, additionalReqs);
    });
};
exports.default = (function (appDir, project) {
    createFiles(appDir, '', [], '$server', []);
    var _a = initTSC(appDir, project), program = _a.program, checker = _a.checker;
    var hooksPaths = [];
    var controllers = [];
    var createText = function (dirPath, cascadingHooks) {
        var input = path_1.default.posix.join(appDir, dirPath);
        var source = program.getSourceFile(path_1.default.join(input, 'index.ts'));
        var results = [];
        var hooks = cascadingHooks;
        if (source) {
            var methods = typescript_1.default.forEachChild(source, function (node) {
                var _a;
                return (typescript_1.default.isTypeAliasDeclaration(node) || typescript_1.default.isInterfaceDeclaration(node)) &&
                    node.name.escapedText === 'Methods' && ((_a = node.modifiers) === null || _a === void 0 ? void 0 : _a.some(function (m) { return m.kind === typescript_1.default.SyntaxKind.ExportKeyword; }))
                    ? checker.getTypeAtLocation(node).getProperties()
                    : undefined;
            });
            var hooksSource = program.getSourceFile(path_1.default.join(input, 'hooks.ts'));
            if (hooksSource) {
                var events = typescript_1.default.forEachChild(hooksSource, function (node) {
                    if (typescript_1.default.isExportAssignment(node)) {
                        return node.forEachChild(function (node) {
                            return typescript_1.default.isCallExpression(node) &&
                                node.forEachChild(function (node) {
                                    if (typescript_1.default.isMethodDeclaration(node) ||
                                        typescript_1.default.isArrowFunction(node) ||
                                        typescript_1.default.isFunctionDeclaration(node)) {
                                        return (node.body &&
                                            checker
                                                .getTypeAtLocation(node.body)
                                                .getProperties()
                                                .map(function (p) {
                                                var typeNode = checker.typeToTypeNode(checker.getTypeOfSymbolAtLocation(p, p.valueDeclaration), undefined, undefined);
                                                return {
                                                    type: p.name,
                                                    isArray: typeNode
                                                        ? typescript_1.default.isArrayTypeNode(typeNode) || typescript_1.default.isTupleTypeNode(typeNode)
                                                        : false
                                                };
                                            }));
                                    }
                                });
                        });
                    }
                });
                if (events) {
                    hooks = __spread(cascadingHooks, [{ name: "hooks" + hooksPaths.length, events: events }]);
                    hooksPaths.push(input + "/hooks");
                }
            }
            if (methods === null || methods === void 0 ? void 0 : methods.length) {
                var controllerSource = program.getSourceFile(path_1.default.join(input, 'controller.ts'));
                var isPromiseMethods_1 = [];
                var ctrlHooksSignature = void 0;
                var resSchemaSignature = void 0;
                if (controllerSource) {
                    isPromiseMethods_1 =
                        typescript_1.default.forEachChild(controllerSource, function (node) {
                            return typescript_1.default.isExportAssignment(node) &&
                                node.forEachChild(function (nod) {
                                    return typescript_1.default.isCallExpression(nod) &&
                                        checker
                                            .getSignaturesOfType(checker.getTypeAtLocation(nod.arguments[nod.arguments.length - 1]), typescript_1.default.SignatureKind.Call)[0]
                                            .getReturnType()
                                            .getProperties()
                                            .map(function (t) {
                                            var _a;
                                            return ((_a = checker
                                                .getSignaturesOfType(checker.getTypeOfSymbolAtLocation(t, t.valueDeclaration), typescript_1.default.SignatureKind.Call)[0]
                                                .getReturnType()
                                                .getSymbol()) === null || _a === void 0 ? void 0 : _a.getEscapedName()) === 'Promise' && t.name;
                                        })
                                            .filter(function (n) { return !!n; });
                                });
                        }) || [];
                    var ctrlHooksNode_1;
                    var resSchemaNode_1;
                    typescript_1.default.forEachChild(controllerSource, function (node) {
                        var _a, _b, _c, _d, _e;
                        if (typescript_1.default.isVariableStatement(node) && ((_a = node.modifiers) === null || _a === void 0 ? void 0 : _a.some(function (m) { return m.kind === typescript_1.default.SyntaxKind.ExportKeyword; }))) {
                            ctrlHooksNode_1 = (_b = node.declarationList.declarations.find(function (d) { return d.name.getText() === 'hooks'; })) !== null && _b !== void 0 ? _b : ctrlHooksNode_1;
                            resSchemaNode_1 = (_c = node.declarationList.declarations.find(function (d) { return d.name.getText() === 'responseSchema'; })) !== null && _c !== void 0 ? _c : resSchemaNode_1;
                        }
                        else if (typescript_1.default.isExportDeclaration(node)) {
                            var exportClause = node.exportClause;
                            if (exportClause && typescript_1.default.isNamedExports(exportClause)) {
                                ctrlHooksNode_1 = (_d = exportClause.elements.find(function (el) { return el.name.text === 'hooks'; })) !== null && _d !== void 0 ? _d : ctrlHooksNode_1;
                                resSchemaNode_1 = (_e = exportClause.elements.find(function (el) { return el.name.text === 'responseSchema'; })) !== null && _e !== void 0 ? _e : resSchemaNode_1;
                            }
                        }
                    });
                    if (ctrlHooksNode_1) {
                        ctrlHooksSignature = checker.getSignaturesOfType(checker.getTypeAtLocation(ctrlHooksNode_1), typescript_1.default.SignatureKind.Call)[0];
                    }
                    if (resSchemaNode_1) {
                        resSchemaSignature = checker.getSignaturesOfType(checker.getTypeAtLocation(resSchemaNode_1), typescript_1.default.SignatureKind.Call)[0];
                    }
                }
                var ctrlHooksEvents_1 = ctrlHooksSignature === null || ctrlHooksSignature === void 0 ? void 0 : ctrlHooksSignature.getReturnType().getProperties().map(function (p) {
                    var typeNode = checker.typeToTypeNode(checker.getTypeOfSymbolAtLocation(p, p.valueDeclaration), undefined, undefined);
                    return {
                        type: p.name,
                        isArray: typeNode
                            ? typescript_1.default.isArrayTypeNode(typeNode) || typescript_1.default.isTupleTypeNode(typeNode)
                            : false
                    };
                });
                var genHookTexts_1 = function (event) {
                    var _a;
                    return __spread(hooks.reduce(function (prev, h) {
                        var ev = h.events.find(function (e) { return e.type === event; });
                        return ev ? __spread(prev, ["" + (ev.isArray ? '...' : '') + h.name + "." + event]) : prev;
                    }, []), ((_a = ctrlHooksEvents_1 === null || ctrlHooksEvents_1 === void 0 ? void 0 : ctrlHooksEvents_1.map(function (e) {
                        return e.type === event
                            ? (e.isArray ? '...' : '') + "ctrlHooks" + controllers.filter(function (c) { return c[1]; }).length + "." + event
                            : '';
                    })) !== null && _a !== void 0 ? _a : []));
                };
                var resSchemaMethods_1 = resSchemaSignature === null || resSchemaSignature === void 0 ? void 0 : resSchemaSignature.getReturnType().getProperties().map(function (p) { return p.name; });
                var genResSchemaText_1 = function (method) {
                    return "schema: { response: responseSchema" + controllers.filter(function (c) { return c[2]; }).length + "." + method + " }";
                };
                results.push(methods
                    .map(function (m) {
                    var props = checker.getTypeOfSymbolAtLocation(m, m.valueDeclaration).getProperties();
                    var query = props.find(function (p) { return p.name === 'query'; });
                    var numberTypeQueryParams = query &&
                        checker
                            .getTypeOfSymbolAtLocation(query, query.valueDeclaration)
                            .getProperties()
                            .map(function (p) {
                            var typeString = checker.typeToString(checker.getTypeOfSymbolAtLocation(p, p.valueDeclaration));
                            return typeString === 'number'
                                ? "['" + p.name + "', " + p.declarations.some(function (d) {
                                    return d.getChildren().some(function (c) { return c.kind === typescript_1.default.SyntaxKind.QuestionToken; });
                                }) + ", false]"
                                : typeString === 'number[]'
                                    ? "['" + p.name + "', " + p.declarations.some(function (d) {
                                        return d.getChildren().some(function (c) { return c.kind === typescript_1.default.SyntaxKind.QuestionToken; });
                                    }) + ", true]"
                                    : null;
                        })
                            .filter(Boolean);
                    var validateInfo = [
                        { name: 'query', val: query },
                        { name: 'body', val: props.find(function (p) { return p.name === 'reqBody'; }) },
                        { name: 'headers', val: props.find(function (p) { return p.name === 'reqHeaders'; }) }
                    ]
                        .filter(function (prop) { return !!prop.val; })
                        .map(function (_a) {
                        var name = _a.name, val = _a.val;
                        return ({
                            name: name,
                            type: checker.getTypeOfSymbolAtLocation(val, val.valueDeclaration),
                            hasQuestion: val.declarations.some(function (d) { return d.getChildAt(1).kind === typescript_1.default.SyntaxKind.QuestionToken; })
                        });
                    })
                        .filter(function (_a) {
                        var type = _a.type;
                        return type.isClass();
                    });
                    var reqFormat = props.find(function (p) { return p.name === 'reqFormat'; });
                    var isFormData = (reqFormat &&
                        checker.typeToString(checker.getTypeOfSymbolAtLocation(reqFormat, reqFormat.valueDeclaration))) === 'FormData';
                    var reqBody = props.find(function (p) { return p.name === 'reqBody'; });
                    var hooksTexts = [
                        'onRequest',
                        'preParsing',
                        'preValidation',
                        'preHandler'
                    ]
                        .map(function (key) {
                        if (key === 'preValidation') {
                            var texts_1 = __spread([
                                numberTypeQueryParams && numberTypeQueryParams.length
                                    ? "parseNumberTypeQueryParams(" + ((query === null || query === void 0 ? void 0 : query.declarations.some(function (d) { return d.getChildAt(1).kind === typescript_1.default.SyntaxKind.QuestionToken; })) ? 'query => !Object.keys(query).length ? [] :'
                                        : '() =>') + " [" + numberTypeQueryParams.join(', ') + "])"
                                    : '',
                                isFormData && reqBody
                                    ? "formatMultipartData([" + checker
                                        .getTypeOfSymbolAtLocation(reqBody, reqBody.valueDeclaration)
                                        .getProperties()
                                        .map(function (p) {
                                        var node = checker.typeToTypeNode(checker.getTypeOfSymbolAtLocation(p, p.valueDeclaration), undefined, undefined);
                                        return node && (typescript_1.default.isArrayTypeNode(node) || typescript_1.default.isTupleTypeNode(node))
                                            ? "['" + p.name + "', " + p.declarations.some(function (d) {
                                                return d
                                                    .getChildren()
                                                    .some(function (c) { return c.kind === typescript_1.default.SyntaxKind.QuestionToken; });
                                            }) + "]"
                                            : undefined;
                                    })
                                        .filter(Boolean)
                                        .join(', ') + "])"
                                    : ''
                            ], genHookTexts_1('preValidation'), [
                                validateInfo.length
                                    ? "createValidateHandler(req => [\n" + validateInfo
                                        .map(function (v) {
                                        return "          " + (v.hasQuestion ? "Object.keys(req." + v.name + " as any).length ? " : '') + "validateOrReject(Object.assign(new Validators." + checker.typeToString(v.type) + "(), req." + v.name + " as any), options.validator)" + (v.hasQuestion ? ' : null' : '');
                                    })
                                        .join(',\n') + "\n        ])"
                                    : '',
                                dirPath.includes('@number')
                                    ? "createTypedParamsHandler(['" + dirPath
                                        .split('/')
                                        .filter(function (p) { return p.includes('@number'); })
                                        .map(function (p) { return p.split('@')[0].slice(1); })
                                        .join("', '") + "'])"
                                    : ''
                            ]).filter(Boolean);
                            return texts_1.length
                                ? key + ": " + (texts_1.length === 1
                                    ? texts_1[0].replace('...', '')
                                    : "[\n        " + texts_1.join(',\n        ') + "\n      ]")
                                : '';
                        }
                        var texts = genHookTexts_1(key).filter(Boolean);
                        return texts.length
                            ? key + ": " + (texts.length === 1 ? texts[0].replace('...', '') : "[" + texts.join(', ') + "]")
                            : '';
                    })
                        .filter(Boolean);
                    return "  fastify." + m.name + "(" + (hooksTexts.length || (resSchemaMethods_1 === null || resSchemaMethods_1 === void 0 ? void 0 : resSchemaMethods_1.includes(m.name))
                        ? '\n    '
                        : '') + "`${basePath}" + ("/" + dirPath)
                        .replace(/\/_/g, '/:')
                        .replace(/@.+?($|\/)/g, '$1') + "`," + (hooksTexts.length || (resSchemaMethods_1 === null || resSchemaMethods_1 === void 0 ? void 0 : resSchemaMethods_1.includes(m.name))
                        ? "\n    {\n      " + ((resSchemaMethods_1 === null || resSchemaMethods_1 === void 0 ? void 0 : resSchemaMethods_1.includes(m.name)) ? "" + genResSchemaText_1(m.name) + (hooksTexts.length ? ',\n      ' : '')
                            : '') + hooksTexts.join(',\n      ') + "\n    }" + (fs_1.default.readFileSync(input + "/$relay.ts", 'utf8').includes('AdditionalRequest')
                            ? ' as RouteShorthandOptions'
                            : '') + ",\n    "
                        : ' ') + (isPromiseMethods_1.includes(m.name) ? 'asyncMethodToHandler' : 'methodToHandler') + "(controller" + controllers.length + "." + m.name + ")" + (hooksTexts.length || (resSchemaMethods_1 === null || resSchemaMethods_1 === void 0 ? void 0 : resSchemaMethods_1.includes(m.name))
                        ? '\n  '
                        : '') + ")\n";
                })
                    .join('\n'));
                controllers.push([input + "/controller", !!ctrlHooksEvents_1, !!resSchemaMethods_1]);
            }
        }
        var childrenDirs = fs_1.default.readdirSync(input, { withFileTypes: true }).filter(function (d) { return d.isDirectory(); });
        if (childrenDirs.length) {
            results.push.apply(results, __spread(childrenDirs
                .filter(function (d) { return !d.name.startsWith('_'); })
                .reduce(function (prev, d) { return __spread(prev, createText(path_1.default.posix.join(dirPath, d.name), hooks)); }, [])));
            var value = childrenDirs.find(function (d) { return d.name.startsWith('_'); });
            if (value) {
                results.push.apply(results, __spread(createText(path_1.default.posix.join(dirPath, value.name), hooks)));
            }
        }
        return results;
    };
    var text = createText('', []).join('\n');
    var ctrlHooks = controllers.filter(function (c) { return c[1]; });
    var resSchemas = controllers.filter(function (c) { return c[2]; });
    return {
        imports: "" + hooksPaths
            .map(function (m, i) {
            return "import hooksFn" + i + " from '" + m.replace(/^api/, './api').replace(appDir, './api') + "'\n";
        })
            .join('') + controllers
            .map(function (ctrl, i) {
            return "import controllerFn" + i + (ctrl[1] || ctrl[2]
                ? ", { " + (ctrl[1] ? "hooks as ctrlHooksFn" + ctrlHooks.indexOf(ctrl) : '') + (ctrl[1] && ctrl[2] ? ', ' : '') + (ctrl[2] ? "responseSchema as responseSchemaFn" + resSchemas.indexOf(ctrl) : '') + " }"
                : '') + " from '" + ctrl[0].replace(/^api/, './api').replace(appDir, './api') + "'\n";
        })
            .join(''),
        consts: "" + hooksPaths
            .map(function (_, i) { return "  const hooks" + i + " = hooksFn" + i + "(fastify)\n"; })
            .join('') + ctrlHooks
            .map(function (_, i) { return "  const ctrlHooks" + i + " = ctrlHooksFn" + i + "(fastify)\n"; })
            .join('') + resSchemas
            .map(function (_, i) { return "  const responseSchema" + i + " = responseSchemaFn" + i + "()\n"; })
            .join('') + controllers
            .map(function (_, i) { return "  const controller" + i + " = controllerFn" + i + "(fastify)\n"; })
            .join(''),
        controllers: text
    };
});
//# sourceMappingURL=createControllersText.js.map