"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var createMethodsString_1 = __importDefault(require("./createMethodsString"));
var createDocComment_1 = __importDefault(require("./createDocComment"));
exports.default = (function (direntTree, basePath, trailingSlash) {
    var imports = [];
    var pathes = [];
    var getMethodsString = function (filepath, methods, indent, newPrefix, newUrl) {
        var importName = "Methods" + imports.length;
        imports.push("import { Methods as " + importName + " } from '" + filepath.replace(/'/g, "\\'") + "'");
        var newPath = "'" + newUrl + (trailingSlash ? '/' : '') + "'";
        if (newPath.length > 2) {
            if (!pathes.includes(newPath))
                pathes.push(newPath);
            newPath = "PATH" + pathes.indexOf(newPath);
        }
        return createMethodsString_1.default(methods, indent, importName, newPrefix && newPath.length > 2 ? "`${" + newPrefix + "}${" + newPath + "}`" : newPrefix || newPath);
    };
    var valCount = 0;
    var createApiString = function (tree, importBasePath, indent, prefix, url, text, methodsOfIndexTsFile) {
        var props = tree.children
            .map(function (dirent) {
            var _a, _b;
            var filename = dirent.name;
            var basename = dirent.isDir ? filename : filename.replace(/\.ts$/, '');
            var hasVal = filename.startsWith('_');
            var valFn = "" + indent + basename
                .replace(/[^a-zA-Z0-9$_]/g, '_')
                .replace(/^(\d)/, '$$$1') + ": {\n<% next %>\n" + indent + "}";
            var newPrefix = prefix;
            var newUrl = url + "/" + basename;
            if (hasVal) {
                var _c = __read(basename.split('@'), 2), valName_1 = _c[0], valType = _c[1];
                var prevUrl = "'" + url + (trailingSlash ? '/' : '') + "'";
                if (url.length && !pathes.includes(prevUrl))
                    pathes.push(prevUrl);
                var duplicatedNames = tree.children.filter(function (d) { return d.name.startsWith(valName_1); });
                var prefixVal = "`" + (prefix ? "${" + prefix + "}" : '') + (url.length ? "${PATH" + pathes.indexOf(prevUrl) + "}" : '') + (url.length && trailingSlash ? '' : '/') + "${val" + valCount + "}" + valName_1.replace(/^[^.]+/, '') + "`";
                newPrefix = "prefix" + valCount;
                newUrl = '';
                valFn = "" + indent + valName_1.replace(/\./g, '_') + (duplicatedNames.length > 1 && valType ? "_" + valType : '') + ": (val" + valCount + ": " + (valType !== null && valType !== void 0 ? valType : 'number | string') + ") => {\n" + indent + "  const " + newPrefix + " = " + prefixVal + "\n\n" + indent + "  return {\n<% next %>\n" + indent + "  }\n" + indent + "}";
                valCount += 1;
            }
            if (dirent.isDir) {
                var methodsOfIndexTsFile_1 = (_a = tree.children.find(function (c) { return c.name === filename + ".ts"; })) !== null && _a !== void 0 ? _a : dirent.tree.children.find(function (c) { return c.name === 'index.ts'; });
                return createApiString(dirent.tree, importBasePath + "/" + filename, "" + indent + (hasVal ? '  ' : '') + "  ", newPrefix, newUrl, "" + createDocComment_1.default(indent, (_b = methodsOfIndexTsFile_1) === null || _b === void 0 ? void 0 : _b.doc) + valFn.replace('<% next %>', '<% props %>'), (methodsOfIndexTsFile_1 === null || methodsOfIndexTsFile_1 === void 0 ? void 0 : methodsOfIndexTsFile_1.isDir) === false
                    ? getMethodsString(importBasePath + "/" + filename, methodsOfIndexTsFile_1.methods, "" + indent + (hasVal ? '  ' : ''), newPrefix, newUrl)
                    : undefined);
            }
            else if (filename !== 'index.ts' && tree.children.every(function (d) { return d.name !== basename; })) {
                return "" + createDocComment_1.default(indent, dirent.doc) + valFn.replace('<% next %>', getMethodsString(importBasePath + "/" + basename, dirent.methods, "" + indent + (hasVal ? '  ' : ''), newPrefix, newUrl));
            }
            return null;
        })
            .filter(function (p) { return !!p; });
        return text.replace('<% props %>', "" + props.join(',\n') + (methodsOfIndexTsFile ? "" + (props.length ? ',\n' : '') + methodsOfIndexTsFile : ''));
    };
    var emptyMethodsRegExp = /.+{\n\n? +},?\n/;
    var rootIndexData = direntTree.children.find(function (c) { return c.name === 'index.ts'; });
    /* eslint-disable no-template-curly-in-string */
    var api = createApiString(direntTree, '.', '    ', '', basePath, "{\n<% props %>\n  }", rootIndexData && !rootIndexData.isDir
        ? getMethodsString('.', rootIndexData.methods, '  ', '', basePath)
        : undefined);
    while (emptyMethodsRegExp.test(api)) {
        api = api.replace(emptyMethodsRegExp, '');
    }
    return { api: api, imports: imports, pathes: pathes };
});
//# sourceMappingURL=createTemplateValues.js.map